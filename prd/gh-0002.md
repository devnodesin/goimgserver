# Core Application Configuration and Command-Line Arguments

## Summary
Implement the core application configuration system with command-line argument parsing for port, image directory, cache directory, and dump functionality using Test-Driven Development (TDD).

## TDD Requirements
**MANDATORY**: Follow TDD Red-Green-Refactor cycle for all implementation.

### Test-First Development Steps
1. **Red**: Write failing tests for each configuration requirement
2. **Green**: Implement minimal code to make tests pass
3. **Refactor**: Clean up implementation while keeping tests green

### Required Tests (Write These First)
- [ ] `TestConfig_ParseArgs_DefaultValues` - Test default values when no args provided
- [ ] `TestConfig_ParseArgs_CustomPort` - Test custom port argument parsing
- [ ] `TestConfig_ParseArgs_CustomDirectories` - Test custom directory path parsing
- [ ] `TestConfig_ParseArgs_DumpFlag` - Test dump flag functionality
- [ ] `TestConfig_ValidatePort_ValidRange` - Test port validation (1-65535)
- [ ] `TestConfig_ValidatePort_InvalidRange` - Test invalid port rejection
- [ ] `TestConfig_ValidateDirectories_ExistingDirs` - Test existing directory validation
- [ ] `TestConfig_ValidateDirectories_CreateMissing` - Test directory creation
- [ ] **`TestConfig_DefaultImage_Detection`** - Test {default_image} detection at startup
- [ ] **`TestConfig_DefaultImage_GeneratePlaceholder`** - Test programmatic placeholder generation
- [ ] **`TestConfig_DefaultImage_ValidationReadable`** - Test {default_image} readability
- [ ] `TestConfig_DumpSettings_ValidOutput` - Test settings dump functionality
- [ ] `TestConfig_String_ProperFormat` - Test configuration string representation

## Acceptance Criteria
- [ ] **TDD Cycle**: All tests written before implementation code
- [ ] Parse command-line arguments with defaults:
  - `--port` (default: 9000)
  - `--imagesdir` (default: ./images) → {image_dir}
  - `--cachedir` (default: ./cache) → {cache_dir}
  - `--dump` (optional flag)
- [ ] Create configuration struct to hold all settings
- [ ] Validate directory paths and create them if they don't exist
- [ ] **Default Image Setup**:
  - Detect {default_image} in {image_dir} (scan for default.jpg, default.jpeg, default.png, default.webp)
  - If no {default_image} found, generate programmatic placeholder (1000x1000px, white bg, "goimgserver" text, black font)
  - Save generated placeholder as {image_dir}/default.jpg
  - Validate {default_image} is readable and processable
- [ ] Implement `--dump` functionality to output current settings to `settings.conf`
- [ ] Add proper error handling for invalid configurations
- [ ] Update main.go to use the new configuration system
- [ ] **Test Coverage**: Achieve >95% test coverage for configuration package

## Technical Details
- Use Go's `flag` package or a more robust CLI library like `cobra`
- Ensure directories are created with appropriate permissions
- Add validation for port numbers (valid range)
- Configuration should be accessible throughout the application
- **Default Image Management**:
  - Scan {image_dir} for existing {default_image} (jpg, jpeg, png, webp extensions)
  - Generate programmatic placeholder using image processing library
  - Validate generated/found {default_image} is processable
  - Store {default_image} path in configuration for runtime access
- **Start with interface design through tests**
- Create test fixtures for various configuration scenarios including {default_image} scenarios

## Test Structure
```
src/config/
├── config.go          # Implementation (write after tests)
├── config_test.go     # Tests (write first)
├── default_image.go   # Default image management (write after tests)
├── default_image_test.go # Default image tests (write first)
└── testdata/
    ├── sample_settings.conf
    ├── test_images/   # Test {default_image} files
    └── expected_placeholder.jpg # Expected generated placeholder
```

## Dependencies
- None (foundation task)

## Priority
High - This is the foundation for all other functionality

## TDD Success Criteria
- [ ] All tests pass
- [ ] No production code exists without corresponding tests
- [ ] Tests are readable and maintainable
- [ ] Implementation is minimal and focused